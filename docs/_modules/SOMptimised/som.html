
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SOMptimised.som &#8212; SOMptimised 1.1</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">SOMptimised 1.1</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../index.html">
                    SOMptimised
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../tutorial/index.html">
   Tutorial/Example
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../tutorial/clustering_iris.html">
     Train the SOM to predict the iris class
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../tutorial/predict_sepal_width.html">
     Predict sepal width
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../tutorial/normalisation.html">
     Of the importance of normalisation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../tutorial/set_and_get.html">
     Set and get extra parameters
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../tutorial/save_and_load.html">
     Save and load SOM
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  ―――――――――――――――
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../API/index.html">
   API
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../API/lr.html">
     Learning strategy submodule
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../API/metric.html">
     Metric submodule
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../API/neighbourhood.html">
     Neighbourhood strategy submodule
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../API/som.html">
     API for the main som module
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/WilfriedMercier/SOMptimised"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/WilfriedMercier/SOMptimised/issues/new?title=Issue%20on%20page%20%2F_modules/SOMptimised/som.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for SOMptimised.som</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">.. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>

<span class="sd">An optimised Self Organising Map which can write and read its values into and from an external file.</span>

<span class="sd">Most of the code comes from **Riley Smith** implementation found in `sklearn-som &lt;https://pypi.org/project/sklearn-som/&gt;`_ python library. Original code from Riley Smith is always marked with :python:`&#39;.. codeauthor:: Riley Smith&#39;`.</span>

<span class="sd">.. The MIT License (MIT)</span>

<span class="sd">    Copyright © 2023 &lt;Wilfried Mercier&gt;</span>

<span class="sd">    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>

<span class="sd">    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>

<span class="sd">    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">joblib</span>
<span class="kn">import</span> <span class="nn">colorama</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">numpy</span>          <span class="k">as</span>     <span class="nn">np</span>
<span class="kn">from</span>   <span class="nn">typing</span>         <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span>   <span class="nn">.learning_rate</span> <span class="kn">import</span> <span class="n">LearningStrategy</span><span class="p">,</span> <span class="n">LinearLearningStrategy</span>
<span class="kn">from</span>   <span class="nn">.neighbourhood</span> <span class="kn">import</span> <span class="n">NeighbourhoodStrategy</span><span class="p">,</span> <span class="n">ConstantRadiusStrategy</span>
<span class="kn">from</span>   <span class="nn">.</span> <span class="n">metric</span>       <span class="kn">import</span> <span class="nn">euclidianMetric</span>

<span class="c1"># Automatically reset any color used with colorama when printing</span>
<span class="n">colorama</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">autoreset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Maximum number of threads on the computer</span>
<span class="n">N_JOBS_MAX</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>

<div class="viewcode-block" id="SOM"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM">[docs]</a><span class="k">class</span> <span class="nc">SOM</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. codeauthor:: Riley Smith</span>
<span class="sd">    </span>
<span class="sd">    Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">    </span>
<span class="sd">    The 2-D, rectangular grid self-organizing map class using Numpy.</span>
<span class="sd">    </span>
<span class="sd">    :param m: (**Optional**) shape along dimension 0 (vertical) of the SOM</span>
<span class="sd">    :type m: :python:`int`</span>
<span class="sd">    :param n: (**Optional**) shape along dimesnion 1 (horizontal) of the SOM</span>
<span class="sd">    :type n: :python:`int`</span>
<span class="sd">    :param dim: (**Optional**) dimensionality (number of features) of the input space</span>
<span class="sd">    :type dim: :python:`int`</span>
<span class="sd">    :param lr: (**Optional**) learning strategy used to update the SOM weights</span>
<span class="sd">    :type lr: :py:class:`~.LearningStrategy`</span>
<span class="sd">    :param sigma: (**Optional**) neighbourhood strategy used to compute the step applied to each weight.</span>
<span class="sd">    :type sigma: :py:class:`~.NeighbourhoodStrategy`</span>
<span class="sd">    :param max_iter: (**Optional**) parameter to stop training if you reach this many interations</span>
<span class="sd">    :type max_iter: :python:`int` or :python:`float`</span>
<span class="sd">    :param metric: (**Optional**) metric used to compute the distance between the train data and the neurons, and between the neurons and the test data</span>
<span class="sd">    :type metric: :python:`callable`</span>
<span class="sd">    :param random_state: (**Optional**) integer seed to the random number generator for weight initialization. This will be used to create a new instance of Numpy&#39;s default random number generator (it will not call np.random.seed()). Specify an integer for deterministic results.</span>
<span class="sd">    :type random_state: :python:`int`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">m</span><span class="p">:</span> <span class="nb">int</span>                       <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> 
                 <span class="n">n</span><span class="p">:</span> <span class="nb">int</span>                       <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> 
                 <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span>                     <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> 
                 <span class="n">lr</span><span class="p">:</span> <span class="n">LearningStrategy</span>         <span class="o">=</span> <span class="n">LinearLearningStrategy</span><span class="p">(</span><span class="n">lr</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> 
                 <span class="n">sigma</span><span class="p">:</span> <span class="n">NeighbourhoodStrategy</span> <span class="o">=</span> <span class="n">ConstantRadiusStrategy</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> 
                 <span class="n">metric</span><span class="p">:</span> <span class="n">callable</span>             <span class="o">=</span> <span class="n">euclidianMetric</span><span class="p">,</span>
                 <span class="n">max_iter</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Init method.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Check types</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">LearningStrategy</span><span class="p">):</span>
           <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;learning strategy lr has type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be a LearningStrategy object.&#39;</span><span class="p">)</span>
           
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">NeighbourhoodStrategy</span><span class="p">):</span>
           <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;neighbourhood radius sigma has type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be a NeighbourhoodStrategy object.&#39;</span><span class="p">)</span>
           
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;dim&#39;</span><span class="p">)):</span>
           <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
              <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;parameter </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> has type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be an int.&#39;</span><span class="p">)</span>
              
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
           <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;max_iter has type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be an int or float.&#39;</span><span class="p">)</span>
              
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
           <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;parameter random_state has type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be an int.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Initialize descriptive features of SOM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span>            <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span>            <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>          <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr</span>           <span class="o">=</span> <span class="n">lr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>        <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span>       <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span>     <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span>
        
        <span class="c1"># Physical parameters associated to each cell in the SOM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phys</span>         <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Initialize weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="n">rng</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>      <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_locations</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># Set after fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inertia</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span>  <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trained</span>     <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="SOM._get_locations"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._get_locations">[docs]</a>    <span class="k">def</span> <span class="nf">_get_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Return the indices of an m by n array. Indices are returned as float to save time.</span>
<span class="sd">        </span>
<span class="sd">        :param m: shape along dimension 0 (vertical) of the SOM</span>
<span class="sd">        :type m: :python:`int`</span>
<span class="sd">        :param n: shape along dimension 1 (horizontal) of the SOM</span>
<span class="sd">        :type n: :python:`int`</span>
<span class="sd">        </span>
<span class="sd">        :returns: indices of the array</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM._find_bmu"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._find_bmu">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bmu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Find the index of the best matching unit for the input vector x.</span>
<span class="sd">        </span>
<span class="sd">        :param x: input vector (1D)</span>
<span class="sd">        :type x: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param metric: (**Optional**) metric to use. If None, the metric provided at init is used.</span>
<span class="sd">        :type metric: :python:`callable`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. This must be a tuple or list of 1D `ndarray`_ with the same shape as **x**. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        </span>
<span class="sd">        :returns: index of the best matching unit</span>
<span class="sd">        :rtype: :python:`int`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">metric</span>   <span class="o">=</span> <span class="n">metric</span> <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.step"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">counter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Do one step of training on the given input vector.</span>
<span class="sd">        </span>
<span class="sd">        :param x: input vector (1D)</span>
<span class="sd">        :type x: `ndarray`_</span>
<span class="sd">        :param counter: global counter used to compute the neighbourhood radius and the learning rate</span>
<span class="sd">        :type counter: :python:`int`</span>
<span class="sd">           </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. This must be a tuple or list of 1D `ndarray`_ with the same shape as **x**. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Get index of best matching unit (we set metric to None to use the one provided in init)</span>
        <span class="n">bmu_index</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        self.bmu_index   = bmu_index</span>
<span class="sd">        print(&#39;bmu index&#39;, self.bmu_index)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Find location of best matching unit</span>
        <span class="n">bmu_location</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">bmu_index</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Find square distance from each weight to the BMU</span>
        <span class="n">diff</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span> <span class="o">-</span> <span class="n">bmu_location</span>
        <span class="n">bmu_distance</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Compute learning rate</span>
        <span class="n">lr</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
        
        <span class="c1"># Compute neighbourhood radius squared</span>
        <span class="n">sigma2</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Compute update on neighborhood</span>
        <span class="n">neighbourhood</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bmu_distance</span> <span class="o">/</span> <span class="n">sigma2</span><span class="p">)</span>
        
        <span class="c1"># Compute local step</span>
        <span class="n">local_step</span>       <span class="o">=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">neighbourhood</span>

        <span class="c1"># Stack local step to be proper shape for update</span>
        <span class="n">local_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">local_step</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Update weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>    <span class="o">+=</span> <span class="n">local_multiplier</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
        
        <span class="k">return</span></div>
    
<div class="viewcode-block" id="SOM._compute_points_inertia"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._compute_points_inertia">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_points_inertia</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                <span class="n">bmus_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span>                           <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span>                                          <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">        </span>
<span class="sd">        Compute the inertia for a set of points. Inertia defined as squared distance from point to closest cluster center (BMU).</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            </span>
<span class="sd">            ***args** and **\**kwargs** are additional arguments and keyword arguments which can be passed depending on the metric used. In this implementation:</span>
<span class="sd">                </span>
<span class="sd">            - **args** must always be a collection of `ndarray`_ with shapes similar to that of **X**</span>
<span class="sd">            - **\**kwargs** are keyword arguments which have no constraints on their type or shape</span>
<span class="sd">             </span>
<span class="sd">            See the metric specific implementation for more details.</span>
<span class="sd">            </span>
<span class="sd">        :param X: input matrix (2D)</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param bmus_indices: (**Optional**) indices of the best matching units for all the points. If :python:`None`, the bmus are computed.</span>
<span class="sd">        :type bmus_indices: :python:`int`, :python:`list` [:python:`int`] or `ndarray`_ [:python:`int`]</span>
<span class="sd">        :param metric: (**Optional**) metric to use. If None, the metric provided at init is used.</span>
<span class="sd">        :type metric: :python:`callable`</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. These arguments are looped similarly to **X**, so they should be a collection of `ndarray`_ with the same shape. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        </span>
<span class="sd">        :returns: inertia for all the points</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">metric</span>       <span class="o">=</span> <span class="n">metric</span> <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span>
        <span class="n">bmus_indices</span> <span class="o">=</span> <span class="n">bmus_indices</span> <span class="k">if</span> <span class="n">bmus_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">metric</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bmus_indices</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.fit"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">unnormalise_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Take data (a tensor of type `float64`_) as input and fit the SOM to that data for the specified number of epochs.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            </span>
<span class="sd">            ***args** and **\**kwargs** are additional arguments and keyword arguments which can be passed depending on the metric used. In this implementation:</span>
<span class="sd">                  </span>
<span class="sd">            - ***args** must always be a collection of `ndarray`_ with shapes similar to that of **X**</span>
<span class="sd">            - **\**kwargs** are keyword arguments which have no constraints on their type or shape</span>
<span class="sd">             </span>
<span class="sd">            See the metric specific implementation for more details.</span>
<span class="sd">        </span>
<span class="sd">        :param X: training data. Must have shape (n, self.dim) where n is the number of training samples.</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param epochs: (**Optional**) number of times to loop through the training data when fitting</span>
<span class="sd">        :type epochs: :python:`int`</span>
<span class="sd">        :param shuffle: (**Optional**) whether or not to randomize the order of train data when fitting. Can be seeded with np.random.seed() prior to calling :py:meth:`~.SOM.fit` method.</span>
<span class="sd">        :type shuffle: :python:`bool`</span>
<span class="sd">        :param n_jobs: (**Optional**) number of threads used to find the BMUs at the end of the loop. This parameter is only used when using :py:meth:`~.SOM._find_bmus_bydata` method.</span>
<span class="sd">        :type n_jobs: :python:`int`</span>
<span class="sd">        :param unnormalise_weights: whether to unnormalise weights or not</span>
<span class="sd">        :type unnormalise_weights: :python:`bool`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. These arguments are looped similarly to **X**, so they should be a collection of `ndarray`_ with the same shape. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Count total number of iterations</span>
        <span class="n">global_iter_counter</span>          <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_samples</span>                    <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">total_iterations</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">epochs</span> <span class="o">*</span> <span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">)</span>
        
        <span class="c1"># Unnormalise the weights</span>
        <span class="k">if</span> <span class="n">unnormalise_weights</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Set the _ntot attribute if the learning rate strategy requires it</span>
        <span class="k">if</span> <span class="s1">&#39;_ntot&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">lr</span><span class="o">.</span><span class="n">ntot</span>              <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_iterations</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
            
            <span class="c1"># Break if past max number of iterations</span>
            <span class="k">if</span> <span class="n">global_iter_counter</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="n">rng</span>                  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">indices</span>              <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
                   
            <span class="k">else</span><span class="p">:</span>
               <span class="n">indices</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>

            <span class="c1"># XXX</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            self.write(&#39;som_init&#39;)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            
            <span class="c1">##########################</span>
            <span class="c1">#        Training        #</span>
            <span class="c1">##########################</span>
            
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                
                <span class="c1"># Break if past max number of iterations</span>
                <span class="k">if</span> <span class="n">global_iter_counter</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">:</span>
                    <span class="k">break</span>
               
                <span class="c1"># Data for the step idx</span>
                <span class="n">inp</span>                  <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                
                <span class="c1"># Additional arguments for the step idx</span>
                <span class="n">step_args</span>            <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">global_iter_counter</span><span class="p">,</span> <span class="o">*</span><span class="n">step_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                  
                <span class="c1"># XXX</span>
                <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                self.write(f&#39;som_{pos}_{idx}&#39;)</span>
<span class="sd">                &#39;&#39;&#39;</span>
                
                <span class="c1"># Update learning rate</span>
                <span class="n">global_iter_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Store bmus of train set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># Compute total inertia (metric set to None because we use the one provided in init)</span>
        <span class="n">inertia</span>                      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_points_inertia</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">bmus_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inertia</span><span class="p">)</span>

        <span class="c1"># Set n_iter_ attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span>                <span class="o">=</span> <span class="n">global_iter_counter</span>

        <span class="c1"># Set trained flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trained</span>                <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="SOM.predict"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Predict cluster for each element in X.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            </span>
<span class="sd">            ***args** and **\**kwargs** are additional arguments and keyword arguments which can be passed depending on the metric used. In this implementation:</span>
<span class="sd">                  </span>
<span class="sd">            - ***args** must always be a collection of `ndarray`_ with shapes similar to that of **X**</span>
<span class="sd">            - **\**kwargs** are keyword arguments which have no constraints on their type or shape</span>
<span class="sd">             </span>
<span class="sd">            See the metric specific implementation for more details.</span>

<span class="sd">        :param X: training data. Must have shape (n, self.dim) where n is the number of training samples.</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param metric: (**Optional**) metric to use. If None, the metric provided at init is used.</span>
<span class="sd">        :type metric: :python:`callable`</span>
<span class="sd">        :param n_jobs: (**Optional**) number of threads used to find the BMUs. This parameter is only used when using :py:meth:`~.SOM._find_bmus_bydata` method.</span>
<span class="sd">        :type n_jobs: :python:`int`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. These arguments are looped similarly to **X**, so they should be a collection of `ndarray`_ with the same shape. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>

<span class="sd">        :returns: an ndarray of shape (n,). The predicted cluster index for each item in X.</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        </span>
<span class="sd">        :raises NotImplmentedError: if :py:meth:`~.SOM.fit` method has not been called already</span>
<span class="sd">        :raises ValueError:</span>
<span class="sd">            </span>
<span class="sd">        * if **X** is not a 2-dimensional array</span>
<span class="sd">        * if the second dimension of **X** has not a length equal to self.dim</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Check to make sure SOM has been fit</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trained</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;SOM object has no predict() method until after calling fit().&#39;</span><span class="p">)</span>

        <span class="c1"># Make sure X has proper shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;X should have two dimensions, not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This SOM has dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s1">. Received input with dimension </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
     
<div class="viewcode-block" id="SOM._find_bmus"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._find_bmus">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bmus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Find the indices of the best matching unit for the input matrix X.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            </span>
<span class="sd">            ***args** and **\**kwargs** are additional arguments and keyword arguments which can be passed depending on the metric used. In this implementation:</span>
<span class="sd">                  </span>
<span class="sd">            - ***args** must always be a collection of `ndarray`_ with shapes similar to that of **X**</span>
<span class="sd">            - **\**kwargs** are keyword arguments which have no constraints on their type or shape</span>
<span class="sd">             </span>
<span class="sd">            See the metric specific implementation for more details.</span>
<span class="sd">        </span>
<span class="sd">        :param X: input matrix (2D)</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param metric: (**Optional**) metric to use. If None, the metric provided at init is used.</span>
<span class="sd">        :type metric: :python:`callable`</span>
<span class="sd">        :param n_jobs: (**Optional**) number of threads used to find the BMUs. This parameter is only used when using :py:meth:`~.SOM._find_bmus_bydata` method.</span>
<span class="sd">        :type n_jobs: :python:`int`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. These arguments are looped similarly to **X**, so they should be a collection of `ndarray`_ with the same shape. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        </span>
<span class="sd">        :returns: indices of the best matching units</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">n_jobs</span><span class="p">:</span>
           <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus_byweight</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus_bydata</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
           
        <span class="k">return</span> <span class="n">labels</span></div>
    
<div class="viewcode-block" id="SOM._find_bmus_bydata"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._find_bmus_bydata">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bmus_bydata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Find the indices of the best matching unit for the input matrix X by looping through the data.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            </span>
<span class="sd">            ***args** and **\**kwargs** are additional arguments and keyword arguments which can be passed depending on the metric used. In this implementation:</span>
<span class="sd">                  </span>
<span class="sd">            - ***args** must always be a collection of `ndarray`_ with shapes similar to that of **X**</span>
<span class="sd">            - **\**kwargs** are keyword arguments which have no constraints on their type or shape</span>
<span class="sd">             </span>
<span class="sd">            See the metric specific implementation for more details.</span>
<span class="sd">            </span>
<span class="sd">        :param X: input matrix (2D)</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param metric: (**Optional**) metric to use. If None, the metric provided at init is used.</span>
<span class="sd">        :type metric: :python:`callable`</span>
<span class="sd">        :param n_jobs: (**Optional**) number of threads used to find the BMUs</span>
<span class="sd">        :type n_jobs: :python:`int`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. These arguments are looped similarly to **X**, so they should be a collection of `ndarray`_ with the same shape. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        </span>
<span class="sd">        :returns: indices of the best matching units</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;n_jobs parameter has type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be an int.&#39;</span><span class="p">)</span>
          
        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_jobs</span> <span class="o">&gt;</span> <span class="n">N_JOBS_MAX</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">colorama</span><span class="o">.</span><span class="n">Fore</span><span class="o">.</span><span class="n">ORANGE</span><span class="si">}</span><span class="s1">Warning:</span><span class="si">{</span><span class="n">colorama</span><span class="o">.</span><span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="si">}</span><span class="s1"> n_jobs must be between 1 and </span><span class="si">{</span><span class="n">N_JOBS_MAX</span><span class="si">}</span><span class="s1"> on your computer. Setting to default value equal to 1...&#39;</span><span class="p">)</span>
            <span class="n">n_jobs</span>  <span class="o">=</span> <span class="mi">1</span>
         
        <span class="k">return</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span><span class="n">joblib</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_bmu</span><span class="p">)(</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="o">*</span><span class="p">[</span><span class="n">arg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span></div>
    
<div class="viewcode-block" id="SOM._find_bmus_byweight"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._find_bmus_byweight">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bmus_byweight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Find the indices of the best matching unit for the input matrix X by looping through the weights.</span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            </span>
<span class="sd">            ***args** and **\**kwargs** are additional arguments and keyword arguments which can be passed depending on the metric used. In this implementation:</span>
<span class="sd">                  </span>
<span class="sd">            - ***args** must always be a collection of `ndarray`_ with shapes similar to that of **X**</span>
<span class="sd">            - **\**kwargs** are keyword arguments which have no constraints on their type or shape</span>
<span class="sd">             </span>
<span class="sd">            See the metric specific implementation for more details.</span>
<span class="sd">            </span>
<span class="sd">        :param X: input matrix (2D)</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param metric: (**Optional**) metric to use. If None, the metric provided at init is used.</span>
<span class="sd">        :type metric: :python:`callable`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: additional arguments to pass to the metric. These arguments are looped similarly to **X**, so they should be a collection of `ndarray`_ with the same shape. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        :param \**kwargs: additional keyword arguments to pass to the metric. See the metric specific signature to know which parameters to pass.</span>
<span class="sd">        </span>
<span class="sd">        :returns: indices of the best matching units</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">metric</span>            <span class="o">=</span> <span class="n">metric</span> <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span>
        
        <span class="c1"># Output indices set to 0 by default</span>
        <span class="n">indices</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="c1"># First, compute distance</span>
        <span class="n">dist</span>              <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># Only update weight position if distance is less than the previous one</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            
            <span class="n">tmp</span>           <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">mask</span>          <span class="o">=</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">dist</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>    <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="n">indices</span></div>
    
<div class="viewcode-block" id="SOM.transform"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Transform the data X into cluster distance space.</span>
<span class="sd">        </span>
<span class="sd">        .. warning::</span>
<span class="sd">           </span>
<span class="sd">           This method has not been updated accordingly with other updates. It may not work as expected.</span>

<span class="sd">        :param X: training data. Must have shape (n, self.dim) where n is the number of training samples.</span>
<span class="sd">        :type X: `ndarray`_</span>

<span class="sd">        :returns: tansformed data of shape (n, self.n*self.m). The Euclidean distance from each item in X to each cluster center.</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Stack data and cluster centers</span>
        <span class="n">X_stack</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cluster_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Compute difference</span>
        <span class="n">diff</span>          <span class="o">=</span> <span class="n">X_stack</span> <span class="o">-</span> <span class="n">cluster_stack</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.fit_predict"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.fit_predict">[docs]</a>    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Convenience method for calling :py:meth:`~.SOM.fit` followed by :py:meth:`~.SOM.predict`.</span>
<span class="sd">        </span>
<span class="sd">        .. warning::</span>
<span class="sd">           </span>
<span class="sd">           This method has not been updated accordingly with other updates. It may not work as expected.</span>

<span class="sd">        :param X: data of shape (n, self.dim). The data to fit and then predict.</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: optional arguments for the :py:meth:`~.SOM.fit` method</span>
<span class="sd">        :param \**kwargs: optional keyword arguments for the :py:meth:`~.SOM.fit` method</span>

<span class="sd">        :returns: ndarray of shape (n,). The index of the predicted cluster for each item in X (after fitting the SOM to the data in X).</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Fit to data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return predictions</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.fit_transform"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Convenience method for calling :py:meth:`~.SOM.fit` followed by :py:meth:`~.SOM.transform`. Unlike in sklearn, this is not implemented more efficiently (the efficiency is the same as calling :py:meth:`~.SOM.fit` directly followed by :py:meth:`~.SOM.transform`).</span>

<span class="sd">        .. warning::</span>
<span class="sd">           </span>
<span class="sd">           This method has not been updated accordingly with other updates. It may not work as expected.</span>
<span class="sd">           </span>
<span class="sd">        :param X: data of shape (n, self.dim) where n is the number of samples</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: optional arguments for the :py:meth:`~.SOM.fit` method</span>
<span class="sd">        :param \**kwargs: optional keyword arguments for the :py:meth:`~.SOM.fit` method</span>

<span class="sd">        :returns: ndarray of shape (n, self.m*self.n). The Euclidean distance from each item in **X** to each cluster center.</span>
<span class="sd">        :rtype: ndarray[:python:`float`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Fit to data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return points in cluster distance space</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    <span class="c1">######################################</span>
    <span class="c1">#             IO methods             #</span>
    <span class="c1">######################################</span>
    
<div class="viewcode-block" id="SOM.write"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Write the result of the SOM into a binary file.</span>
<span class="sd">        </span>
<span class="sd">        :param fname: output filename</span>
<span class="sd">        :type fname: :python:`str`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: other arguments passed to `pickle.dump`_</span>
<span class="sd">        :parma \**kwargs: other keyword arguments passed to `pickle.dump`_</span>
<span class="sd">        </span>
<span class="sd">        :raises TypeError: if **fname** is not of type :python:`str`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;fname is of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be of type str.&#39;</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
        <span class="k">return</span></div>
    
<div class="viewcode-block" id="SOM.read"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.read">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">fname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Read the result of a SOM written into a binary file with the :py:meth:`~.SOM.write` method.</span>
<span class="sd">        </span>
<span class="sd">        :param fname: input file</span>
<span class="sd">        :type fname: :python:`str`</span>
<span class="sd">        </span>
<span class="sd">        :param \*args: other arguments passed to `pickle.load`_</span>
<span class="sd">        :parma \**kwargs: other keyword arguments passed to `pickle.load`_</span>
<span class="sd">        </span>
<span class="sd">        :returns: the loaded SOM object</span>
<span class="sd">        :rtype: :py:class:`~.SOM`</span>
<span class="sd">        </span>
<span class="sd">        :raises TypeError: if **fname** is not of type :python:`str`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;fname is of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be of type str.&#39;</span><span class="p">)</span>
            
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    <span class="c1">#################################################</span>
    <span class="c1">#          Physical parameters methods          #</span>
    <span class="c1">#################################################</span>
    
<div class="viewcode-block" id="SOM.get"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Return the given physical parameters if it exists.</span>
<span class="sd">        </span>
<span class="sd">        :param param: parameter to return</span>
<span class="sd">        :type param: :python:`str`</span>
<span class="sd">        </span>
<span class="sd">        :returns: array of physical parameter value associated to each node</span>
<span class="sd">        :rtype: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :raises KeyError: if **param** is not found</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;physical parameter </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1"> not found.&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys</span><span class="p">[</span><span class="n">param</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="SOM.set"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Set the given physical parameter. Must be an array of shape (self.n*self.m,)</span>
<span class="sd">        </span>
<span class="sd">        :param param: parameter to set</span>
<span class="sd">        :type param: :python:`str`</span>
<span class="sd">        :param value: array with the values of the physical parameter to store</span>
<span class="sd">        :type value: `ndarray`_</span>
<span class="sd">    </span>
<span class="sd">        :raises ValueError: if **value** is not a 1-dimensional array of length self.m*self.n</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;value has shape </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must have a shape (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">phys</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        
        <span class="k">return</span></div>
    
    <span class="c1">##########################################</span>
    <span class="c1">#               Properties               #</span>
    <span class="c1">##########################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cluster_centers_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Give the coordinates of each cluster centre as an array of shape (m, n, dim).</span>
<span class="sd">        </span>
<span class="sd">        :returns: cluster centres</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inertia_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Inertia.</span>
<span class="sd">        </span>
<span class="sd">        :returns: computed inertia</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        </span>
<span class="sd">        :raises AttributeError: if the SOM does not have the inertia already computed</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;SOM does not have inertia until after calling fit().&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_iter_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Number of iterations.</span>
<span class="sd">        </span>
<span class="sd">        :returns: number of iterations</span>
<span class="sd">        :rtype: :python:`int`</span>
<span class="sd">        </span>
<span class="sd">        :rtype AttributeError: if the number of iterations is not initialised yet</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;SOM does not have n_iter_ attribute until after calling fit().&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">train_bmus_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Best matching units indices for the train set.</span>
<span class="sd">        </span>
<span class="sd">        :returns: BMUs indices for the train set</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        </span>
<span class="sd">        :rtype AttributeError: if the number of iterations is not initialised yet</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;SOM does have train_bmus_ attribute until after calling fit().&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span></div>

</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Wilfried Mercier<br/>
  
      &copy; Copyright 2022, Wilfried Mercier.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>