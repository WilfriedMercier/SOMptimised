
<!DOCTYPE html>

<html lang="en">
<head>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta charset="utf-8"/>
<title>SOMptimised.som | SOMptimised 1.0 documentation</title>
<link href="../../_static/pygments.css" rel="stylesheet"/>
<link href="../../_static/theme.313ea551d1799b2102b1.css" rel="stylesheet"/>
<link href="../../_static/plot_directive.css" rel="stylesheet"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="../../genindex.html" rel="index" title="Index"/>
</head>
<body class="antialiased text-gray">
<div class="h-screen xl:grid xl:grid-layout" data-action="keydown@window-&gt;search#focus" data-controller="sidebar search" id="page">
<a class="block text-xl bg-white py-4 z-20 absolute top-0 h-18 inset-x-0 text-center transform -translate-y-full focus:translate-y-0 focus:outline-none transition-transform duration-75" href="#somptimised-som" title="Skip navigation links">Skip to content</a>
<header class="grid-area-header z-10 h-14 sm:h-18">
<div class="bg-gray-dark shadow-md flex items-center h-full xl:px-2 relative"><div class="flex items-center">
<button class="xl:hidden h-14 w-14 sm:h-18 sm:w-18 leading-14 sm:leading-18 text-gray-100 hover:bg-gray-700 hover:text-brand focus:outline-none focus:bg-gray-700 focus:text-brand" data-action="sidebar#open" data-sidebar-target="hamburger">
<span class="sr-only">Open navigation menu</span>
<svg aria-hidden="true" class="fill-current h-8 w-8" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg>
</button><a aria-label="Back to homepage" class="hover:bg-gray-700 focus:bg-gray-700 focus:outline-none tooltipped tooltipped-sw" href="../../index.html"><span class="hidden lg:inline-block shrink-0 font-medium text-gray-100 mx-5 leading-14 sm:leading-18 tracking-wider">SOMptimised 1.0 documentation</span>
</a></div><div class="flex justify-end items-center flex-1"><form action="../../search.html" class="flex print:hidden justify-between items-center leading-14 sm:leading-18 md:ml-4 bg-gray-dark text-gray-300 focus-within:bg-gray-50 focus-within:text-gray-800 focus-within:absolute focus-within:inset-x-0 focus-within:top-0 md:focus-within:w-full md:focus-within:static" data-action="click-&gt;search#focusSearchInput" id="searchbox" method="get">
<button aria-label="Get search results" class="text-inherit h-14 w-14 sm:h-18 sm:w-18" tabindex="-1">
<svg aria-hidden="true" class="fill-current stroke-current h-8 w-8" stroke-width="0.5" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></svg>
</button>
<input aria-label="Search the docs" class="pr-2 bg-transparent text-inherit focus:outline-none w-0 md:w-auto focus:w-full transition-all duration-100" data-search-target="searchInput" id="search-input" name="q" placeholder="Search the docs" type="search"/>
</form><div class="shrink-0"><a class="h-14 sm:h-18 inline-block leading-14 sm:leading-18 text-gray-100 bg-transparent tracking-wide font-medium hover:text-brand focus:bg-gray-700 focus:outline-none hover:no-underline focus:text-brand px-4" href="../../https%3A//github.com/WilfriedMercier/SOMptimised.html">GitHub</a></div></div>
</div>
</header>
<aside class="grid-area-sidebar h-full fixed xl:relative inset-y-0 left-0 z-20 xl:z-0 print:hidden overflow-y-auto transition-all transform transform-gpu -translate-x-full opacity-0 duration-300 xl:translate-x-0 xl:opacity-100" data-sidebar-target="sidebar">
<nav class="h-full overflow-y-auto bg-white text-gray-600 pt-8 flex flex-col" role="navigation">
<div class="nav-toc flex-1 pl-6"><ul>
<li class="toctree-l1"><div class="nav-link"><svg class="expand" data-action="click-&gt;sidebar#expand keydown-&gt;sidebar#expandKeyPressed" tabindex="0" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></svg><a class="reference internal" data-action="click-&gt;sidebar#close" href="../../tutorial/index.html">Tutorial/Example</a></div><ul>
<li class="toctree-l2"><div class="nav-link"><a class="reference internal" data-action="click-&gt;sidebar#close" href="../../tutorial/index.html#running-a-som">1. Running a SOM</a></div></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">―――――――――――――――</span></p>
<ul>
<li class="toctree-l1"><div class="nav-link"><svg class="expand" data-action="click-&gt;sidebar#expand keydown-&gt;sidebar#expandKeyPressed" tabindex="0" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></svg><a class="reference internal" data-action="click-&gt;sidebar#close" href="../../API/index.html">API</a></div><ul>
<li class="toctree-l2"><div class="nav-link"><a class="reference internal" data-action="click-&gt;sidebar#close" href="../../API/som.html">API for the som module</a></div></li>
</ul>
</li>
</ul>
</div>
<button class="text-4xl text-gray-800 p-4 bottom-0 hover:text-brand xl:hidden focus:text-brand self-center" data-action="" title="Close navigation menu">
<span class="sr-only">Close navigation menu</span>
<svg aria-hidden="true" class="fill-current stroke-current h-6 w-6" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</aside>
<main class="px-10 xl:ml-fluid grid-area-main overflow-y-auto flex flex-col h-full mx-0 md:mx-auto xl:mr-0" data-action="scroll-&gt;scroll#showButton" data-controller="scroll"><nav aria-label="breadcrumbs" class="print:hidden mt-12 text-sm text-gray-light" role="navigation">
<a class="text-gray-light text-sm hover:text-gray-dark font-medium focus:text-gray-dark" href="../../index.html">SOMptimised 1.0 documentation</a>
<span class="mr-1">/</span><a class="text-gray-light text-sm hover:text-gray-dark" href="../index.html">Module code</a>
<span class="mr-1">/</span><span aria-current="page">SOMptimised.som</span>
</nav>
<article class="flex-1" role="main">
<h1>Source code for SOMptimised.som</h1><div class="highlight"><pre>
<code><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sa">r</span><span class="sd">"""</span>
<span class="sd">.. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>

<span class="sd">An optimised Self Organising Map which can write and read its values into and from an external file.</span>

<span class="sd">Most of the code comes from **Riley Smith** implementation found in `sklearn-som &lt;https://pypi.org/project/sklearn-som/&gt;`_ python library. Original code from Riley Smith is always marked with :python:`'.. codeauthor:: Riley Smith'`.</span>

<span class="sd">.. The MIT License (MIT)</span>

<span class="sd">    Copyright © 2022 &lt;copyright holders&gt;</span>

<span class="sd">    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>

<span class="sd">    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>

<span class="sd">    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="sd">"""</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">numpy</span>  <span class="k">as</span>     <span class="nn">np</span>
<span class="kn">from</span>   <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<div class="viewcode-block" id="SOM"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM">[docs]</a><span class="k">class</span> <span class="nc">SOM</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    .. codeauthor:: Riley Smith</span>
<span class="sd">    </span>
<span class="sd">    The 2-D, rectangular grid self-organizing map class using Numpy.</span>
<span class="sd">    </span>
<span class="sd">    :param m: (**Optional**) shape along dimension 0 (vertical) of the SOM</span>
<span class="sd">    :type m: :python:`int`</span>
<span class="sd">    :param n: (**Optional**) shape along dimesnion 1 (horizontal) of the SOM</span>
<span class="sd">    :type n: :python:`int`</span>
<span class="sd">    :param dim: (**Optional**) dimensionality (number of features) of the input space</span>
<span class="sd">    :type dim: :python:`int`</span>
<span class="sd">    :param lr: (**Optional**) initial step size for updating the SOM weights.</span>
<span class="sd">    :type lr: :python:`float`</span>
<span class="sd">    :param sigma: (**Optional**) magnitude of change to each weight. Does not update over training (as does learning rate). Higher values mean more aggressive updates to weights.</span>
<span class="sd">    :type sigma: :python:`float`</span>
<span class="sd">    :param max_iter: (**Optional**) parameter to stop training if you reach this many interation.</span>
<span class="sd">    :type max_iter: :python:`int`</span>
<span class="sd">    :param random_state: (**Optional**) integer seed to the random number generator for weight initialization. This will be used to create a new instance of Numpy's default random number generator (it will not call np.random.seed()). Specify an integer for deterministic results.</span>
<span class="sd">    :type random_state: :python:`int`</span>
<span class="sd">    """</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">lr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Init method.</span>
<span class="sd">        """</span>
        
        <span class="c1"># Initialize descriptive features of SOM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span>            <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span>            <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>          <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>        <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_lr</span>   <span class="o">=</span> <span class="n">lr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr</span>           <span class="o">=</span> <span class="n">lr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>        <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma2</span>       <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span>     <span class="o">=</span> <span class="n">max_iter</span>
        
        <span class="c1"># Physical parameters associated to each cell in the SOM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phys</span>         <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Initialize weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="n">rng</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>      <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_locations</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># Set after fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inertia</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span>  <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trained</span>     <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="SOM._get_locations"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._get_locations">[docs]</a>    <span class="k">def</span> <span class="nf">_get_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Return the indices of an m by n array. Indices are returned as float to save time.</span>
<span class="sd">        </span>
<span class="sd">        :param m: shape along dimension 0 (vertical) of the SOM</span>
<span class="sd">        :type m: :python:`int`</span>
<span class="sd">        :param n: shape along dimension 1 (horizontal) of the SOM</span>
<span class="sd">        :type n: :python:`int`</span>
<span class="sd">        </span>
<span class="sd">        :returns: indices of the array</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        """</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM._find_bmu"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._find_bmu">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bmu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Find the index of the best matching unit for the input vector x.</span>
<span class="sd">        </span>
<span class="sd">        :param x: input vector (1D)</span>
<span class="sd">        :type x: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :returns: index of the best matching unit</span>
<span class="sd">        :rtype: :python:`int`</span>
<span class="sd">        """</span>
        
        <span class="n">diff</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">-</span><span class="n">x</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.step"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Do one step of training on the given input vector.</span>
<span class="sd">        </span>
<span class="sd">        :param x: input vector (1D)</span>
<span class="sd">        :type x: `ndarray`_</span>
<span class="sd">        """</span>

        <span class="c1"># Get index of best matching unit</span>
        <span class="n">bmu_index</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Find location of best matching unit</span>
        <span class="n">bmu_location</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">bmu_index</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Find square distance from each weight to the BMU</span>
        <span class="n">diff</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span> <span class="o">-</span> <span class="n">bmu_location</span>
        <span class="n">bmu_distance</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Compute update on neighborhood</span>
        <span class="n">neighborhood</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bmu_distance</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma2</span><span class="p">))</span>
        <span class="n">local_step</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">*</span> <span class="n">neighborhood</span>

        <span class="c1"># Stack local step to be proper shape for update</span>
        <span class="n">local_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">local_step</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Update weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>    <span class="o">+=</span> <span class="n">local_multiplier</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
        
        <span class="k">return</span></div>

<div class="viewcode-block" id="SOM._compute_point_inertia"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._compute_point_inertia">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_point_inertia</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Compute the inertia of a single point. Inertia defined as squared distance from point to closest cluster center (BMU)</span>
<span class="sd">        </span>
<span class="sd">        :param x: input vector (1D)</span>
<span class="sd">        :type x: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :returns: inertia for the point</span>
<span class="sd">        :rtype: :python:`float`</span>
<span class="sd">        """</span>
        
        <span class="c1"># Find BMU</span>
        <span class="n">bmu_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">bmu</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bmu_index</span><span class="p">]</span>
        
        <span class="c1"># Compute sum of squared distance (just euclidean distance) from x to bmu</span>
        <span class="n">diff</span>      <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">bmu</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">diff</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SOM._compute_points_inertia"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._compute_points_inertia">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_points_inertia</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">bmus_indices</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;</span>
<span class="sd">        </span>
<span class="sd">        Compute the inertia for a set of points. Inertia defined as squared distance from point to closest cluster center (BMU)</span>
<span class="sd">        </span>
<span class="sd">        :param X: input matrix (2D)</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param bmus_indices: (**Optional**) indices of the best matching units for all the points. If :python:`None`, the bmus are computed.</span>
<span class="sd">        </span>
<span class="sd">        :returns: inertia for all the points</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        """</span>
        
        <span class="k">if</span> <span class="n">bmus_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bmus_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus_byweight</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            
        <span class="n">diff</span>    <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bmus_indices</span><span class="p">]</span>
        
        <span class="k">return</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.fit"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Take data (a tensor of type `float64`_) as input and fit the SOM to that data for the specified number of epochs.</span>

<span class="sd">        :param X: training data. Must have shape (n, self.dim) where n is the number of training samples.</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param epochs: (**Optional**) number of times to loop through the training data when fitting</span>
<span class="sd">        :type epochs: :python:`int`</span>
<span class="sd">        :param shuffle: (**Optional**) whether or not to randomize the order of train data when fitting. Can be seeded with np.random.seed() prior to calling fit.</span>
<span class="sd">        :type shuffle: :python:`bool`</span>
<span class="sd">        """</span>
        
        <span class="c1"># Count total number of iterations</span>
        <span class="n">global_iter_counter</span>          <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_samples</span>                    <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">total_iterations</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">epochs</span> <span class="o">*</span> <span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
            
            <span class="c1"># Break if past max number of iterations</span>
            <span class="k">if</span> <span class="n">global_iter_counter</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="n">rng</span>                  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">indices</span>              <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>

            <span class="c1"># Train</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                
                <span class="c1"># Break if past max number of iterations</span>
                <span class="k">if</span> <span class="n">global_iter_counter</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">:</span>
                    <span class="k">break</span>
                
                <span class="c1"># Do one step of training</span>
                <span class="n">inp</span>                  <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
                
                <span class="c1"># Update learning rate</span>
                <span class="n">global_iter_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lr</span>              <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">global_iter_counter</span> <span class="o">/</span> <span class="n">total_iterations</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_lr</span>

        <span class="c1"># Store bmus of train set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus_byweight</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># Compute total inertia</span>
        <span class="n">inertia</span>                      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_points_inertia</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bmus_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inertia</span><span class="p">)</span>

        <span class="c1"># Set n_iter_ attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span>                <span class="o">=</span> <span class="n">global_iter_counter</span>

        <span class="c1"># Set trained flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trained</span>                <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="SOM.predict"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Modified by Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt;.</span>
<span class="sd">        </span>
<span class="sd">        Predict cluster for each element in X.</span>

<span class="sd">        :param X: training data. Must have shape (n, self.dim) where n is the number of training samples.</span>
<span class="sd">        :type X: `ndarray`_</span>

<span class="sd">        :returns: an ndarray of shape (n,). The predicted cluster index for each item in X.</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        </span>
<span class="sd">        :raises NotImplmentedError: if :py:meth:`~.SOM.fit` method has not been called already</span>
<span class="sd">        :raises ValueError:</span>
<span class="sd">            </span>
<span class="sd">        * if **X** is not a 2-dimensional array</span>
<span class="sd">        * if the second dimension of **X** has not a length equal to self.dim</span>
<span class="sd">        """</span>
        
        <span class="c1"># Check to make sure SOM has been fit</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trained</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'SOM object has no predict() method until after calling fit().'</span><span class="p">)</span>

        <span class="c1"># Make sure X has proper shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'X should have two dimensions, not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>
            
        <span class="k">if</span>  <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'This SOM has dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s1">. Received input with dimension </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>
        
        <span class="c1">#labels = self._find_bmus_bydata(X)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bmus_byweight</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">labels</span></div>
    
<div class="viewcode-block" id="SOM._find_bmus_bydata"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._find_bmus_bydata">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bmus_bydata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Find the indices of the best matching unit for the input matrix X by looping through the data.</span>
<span class="sd">        </span>
<span class="sd">        :param X: input matrix (2D)</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :returns: indices of the best matching units</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        """</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_bmu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="SOM._find_bmus_byweight"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM._find_bmus_byweight">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bmus_byweight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Find the indices of the best matching unit for the input matrix X by looping through the weights.</span>
<span class="sd">        </span>
<span class="sd">        :param X: input matrix (2D)</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :returns: indices of the best matching units</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        """</span>
        
        <span class="c1"># Output indices set to 0 by default</span>
        <span class="n">indices</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="c1"># Compute first distance</span>
        <span class="n">diff</span>              <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dist</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Only update weight position if distance is less than the previous one</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            
            <span class="n">diff</span>          <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">weight</span>
            <span class="n">tmp</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="o">*</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mask</span>          <span class="o">=</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">dist</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>    <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="n">indices</span></div>
    
<div class="viewcode-block" id="SOM.transform"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Transform the data X into cluster distance space.</span>

<span class="sd">        :param X: training data. Must have shape (n, self.dim) where n is the number of training samples.</span>
<span class="sd">        :type X: `ndarray`_</span>

<span class="sd">        :returns: tansformed data of shape (n, self.n*self.m). The Euclidean distance from each item in X to each cluster center.</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        """</span>
        
        <span class="c1"># Stack data and cluster centers</span>
        <span class="n">X_stack</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cluster_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Compute difference</span>
        <span class="n">diff</span>          <span class="o">=</span> <span class="n">X_stack</span> <span class="o">-</span> <span class="n">cluster_stack</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.fit_predict"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.fit_predict">[docs]</a>    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Convenience method for calling fit(X) followed by predict(X).</span>

<span class="sd">        :param X: data of shape (n, self.dim). The data to fit and then predict.</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param \**kwargs: optional keyword arguments for the :py:meth:`~.SOM.fit` method</span>

<span class="sd">        :returns: ndarray of shape (n,). The index of the predicted cluster for each item in X (after fitting the SOM to the data in X).</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        """</span>
        <span class="c1"># Fit to data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return predictions</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="SOM.fit_transform"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">"""</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Convenience method for calling fit(X) followed by transform(X). Unlike in sklearn, this is not implemented more efficiently (the efficiency is the same as calling fit(X) directly followed by transform(X)).</span>

<span class="sd">        :param X: data of shape (n, self.dim) where n is the number of samples</span>
<span class="sd">        :type X: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :param \**kwargs: optional keyword arguments for the :py:meth:`~.SOM.fit` method</span>

<span class="sd">        :returns: ndarray of shape (n, self.m*self.n). The Euclidean distance from each item in **X** to each cluster center.</span>
<span class="sd">        :rtype: ndarray[:python:`float`]</span>
<span class="sd">        """</span>
        <span class="c1"># Fit to data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return points in cluster distance space</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>
    
    <span class="c1">######################################</span>
    <span class="c1">#             IO methods             #</span>
    <span class="c1">######################################</span>
    
<div class="viewcode-block" id="SOM.write"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Write the result of the SOM into a binary file.</span>
<span class="sd">        </span>
<span class="sd">        :param fname: output filename</span>
<span class="sd">        :type fname: :python:`str`</span>
<span class="sd">        </span>
<span class="sd">        :raises TypeError: if **fname** is not of type :python:`str`</span>
<span class="sd">        '''</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'fname is of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be of type str.'</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            
        <span class="k">return</span></div>
    
<div class="viewcode-block" id="SOM.read"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.read">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">fname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Read the result of a SOM written into a binary file with the :py:meth:`~.SOM.write` method.</span>
<span class="sd">        </span>
<span class="sd">        :param fname: input file</span>
<span class="sd">        :type fname: :python:`str`</span>
<span class="sd">        </span>
<span class="sd">        :returns: the loaded SOM object</span>
<span class="sd">        :rtype: :py:class:`~.SOM`</span>
<span class="sd">        </span>
<span class="sd">        :raises TypeError: if **fname** is not of type :python:`str`</span>
<span class="sd">        '''</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'fname is of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must be of type str.'</span><span class="p">)</span>
            
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>
    
    <span class="c1">#################################################</span>
    <span class="c1">#          Physical parameters methods          #</span>
    <span class="c1">#################################################</span>
    
<div class="viewcode-block" id="SOM.get"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Return the given physical parameters if it exists.</span>
<span class="sd">        </span>
<span class="sd">        :param param: parameter to return</span>
<span class="sd">        :type param: :python:`str`</span>
<span class="sd">        </span>
<span class="sd">        :returns: array of physical parameter value associated to each node</span>
<span class="sd">        :rtype: `ndarray`_</span>
<span class="sd">        </span>
<span class="sd">        :raises KeyError: if **param** is not found</span>
<span class="sd">        '''</span>
        
        <span class="k">if</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'physical parameter </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1"> not found.'</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys</span><span class="p">[</span><span class="n">param</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="SOM.set"><a class="viewcode-back" href="../../API/som.html#SOMptimised.som.SOM.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Set the given physical parameter. Must be an array of shape (self.n*self.m,)</span>
<span class="sd">        </span>
<span class="sd">        :param param: parameter to set</span>
<span class="sd">        :type param: :python:`str`</span>
<span class="sd">        :param value: array with the values of the physical parameter to store</span>
<span class="sd">        :type value: `ndarray`_</span>
<span class="sd">    </span>
<span class="sd">        :raises ValueError: if **value** is not a 1-dimensional array of length self.m*self.n</span>
<span class="sd">        '''</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'value has shape </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1"> but it must have a shape (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">).'</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">phys</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        
        <span class="k">return</span></div>
    
    <span class="c1">##########################################</span>
    <span class="c1">#               Properties               #</span>
    <span class="c1">##########################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cluster_centers_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Give the coordinates of each cluster centre as an array of shape (m, n, dim).</span>
<span class="sd">        </span>
<span class="sd">        :returns: cluster centres</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        '''</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inertia_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Inertia.</span>
<span class="sd">        </span>
<span class="sd">        :returns: computed inertia</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`float`]</span>
<span class="sd">        </span>
<span class="sd">        :raises AttributeError: if the SOM does not have the inertia already computed</span>
<span class="sd">        '''</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">'SOM does not have inertia until after calling fit().'</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_iter_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Riley Smith</span>
<span class="sd">        </span>
<span class="sd">        Number of iterations.</span>
<span class="sd">        </span>
<span class="sd">        :returns: number of iterations</span>
<span class="sd">        :rtype: :python:`int`</span>
<span class="sd">        </span>
<span class="sd">        :rtype AttributeError: if the number of iterations is not initialised yet</span>
<span class="sd">        '''</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">'SOM does not have n_iter_ attribute until after calling fit().'</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_iter_</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">train_bmus_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">'''</span>
<span class="sd">        .. codeauthor:: Wilfried Mercier - IRAP &lt;wilfried.mercier@irap.omp.eu&gt; </span>
<span class="sd">        </span>
<span class="sd">        Best matching units indices for the train set.</span>
<span class="sd">        </span>
<span class="sd">        :returns: BMUs indices for the train set</span>
<span class="sd">        :rtype: `ndarray`_ [:python:`int`]</span>
<span class="sd">        </span>
<span class="sd">        :rtype AttributeError: if the number of iterations is not initialised yet</span>
<span class="sd">        '''</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">'SOM does have train_bmus_ attribute until after calling fit().'</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_bmus</span></div>

</code></pre></div>
</article>
<footer>
<div class="mt-20 mb-4 text-sm text-gray-700">© 2022, Wilfried Mercier Made with <a href="https://www.sphinx-doc.org">Sphinx 4.4.0</a></div>
</footer></main>
<button class="fixed bottom-0 right-0 z-20 opacity-0 p-4 m-4 tracking-wide bg-gray-900 text-gray-100 transition transform transform-gpu duration-500 translate-y-full" data-action="search#hideSnackbar" data-search-target="snackbar">
  Clear highlights
</button><div class="fixed hidden inset-0 bg-black bg-opacity-50" data-action="click-&gt;sidebar#close" data-sidebar-target="screen">
</div>
</div>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
<script src="../../_static/jquery.js"></script>
<script src="../../_static/underscore.js"></script>
<script src="../../_static/doctools.js"></script>
<script src="../../_static/theme.3666d2347a4c66e5d7a8.js"></script>
</body>
</html>